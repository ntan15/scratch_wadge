
#if USE_DOUBLE
#define dfloat double
#define dfloat4 double4
#define LOGDF log
#define POWDF pow
#define EXPDF exp
#else
#define dfloat float
#define dfloat4 float4
#define LOGDF logf
#define POWDF powf
#define EXPDF expf
#endif

#define TESTING

// helpful functions
#define avg(a, b) .5f * (a + b)
#define pfun(rho, u, v, E) ((p_gamma - 1.f) * (E - .5f * rho * (u * u + v * v)))
#define beta(rho, u, v, E) (0.5f * rho / (pfun(rho, u, v, E))) // inverse temp

// map conservation to entropy vars
#define pfun(rho, u, v, E) ((p_gamma - 1.f) * (E - .5f * rho * (u * u + v * v)))
#define rhoeU(rho, rhou, rhov, E) (E - .5f * (rhou * rhou + rhov * rhov) / rho)
#define sU(rho, rhou, rhov, E)                                          \
  (LOGDF((p_gamma - 1.f) * rhoeU(rho, rhou, rhov, E) / POWDF(rho, p_gamma)))

// map entropy to conservation vars
#define sV(V1, V2, V3, V4) (p_gamma - V1 + (V2 * V2 + V3 * V3) / (2.f * V4))
#define rhoeV(V1, V2, V3, V4)                                           \
  (POWDF((p_gamma - 1.f) / POWDF(-V4, p_gamma), 1.f / (p_gamma - 1.f)) * \
   EXPDF(-sV(V1, V2, V3, V4) / (p_gamma - 1.f)))

// occa function
dfloat logmean(dfloat aL, dfloat aR)
{
#ifdef TESTING
  const dfloat xi = aL / aR;
  const dfloat f = (xi - 1.f) / (xi + 1.f);
  const dfloat u = f * f;
  const dfloat u2 = u * u;

  dfloat F = LOGDF(xi) * f;
  if (fabs(u) < 1.fe-3)
    {
      F = 630.f + 210.f * u + 126.f * u2 + 90.f * u2 * u + 70.f * u2 * u2;
      return (aL + aR) * 315.f / F;
    }
   else
    {
      return (aL + aR) / F;
    }
#else
  const dfloat xi = aL / aR;
  const dfloat f = (xi - 1.f) / (xi + 1.f);
  const dfloat u = f * f;
  const dfloat u2 = u * u;

  dfloat F = LOGDF(xi) / 2.f / f;
  if (fabs(u) < 1.fe-3)
    {
      F = 1.f + u / 3.f + u2 / 5.f + u2 * u / 7.f + u2 * u2 / 9.f;
    }
  return (aL + aR) / (2.f * F);
#endif
}

void VU(dfloat rho, dfloat rhou, dfloat rhov, dfloat E, dfloat &V1, dfloat &V2,
        dfloat &V3, dfloat &V4)
{

#ifdef TESTING
  const dfloat rhoe = rhoeU(rho, rhou, rhov, E);
  const dfloat invrhoe = 1/rhoe;
  V1 = (-E + rhoe * (p_gamma + 1.f - sU(rho, rhou, rhov, E))) * invrhoe;
  V2 = rhou * invrhoe;
  V3 = rhov * invrhoe;
  V4 = (-rho) * invrhoe;
#else
  const dfloat rhoe = rhoeU(rho, rhou, rhov, E);
  V1 = (-E + rhoe * (p_gamma + 1.f - sU(rho, rhou, rhov, E))) / rhoe;
  V2 = rhou / rhoe;
  V3 = rhov / rhoe;
  V4 = (-rho) / rhoe;
#endif
}

void UV(dfloat V1, dfloat V2, dfloat V3, dfloat V4, dfloat &rho, dfloat &rhou,
        dfloat &rhov, dfloat &E)
{

  const dfloat rhoe = rhoeV(V1, V2, V3, V4);
  rho = rhoe * (-V4);
  rhou = rhoe * (V2);
  rhov = rhoe * (V3);
  E = rhoe * (1.f - (V2 * V2 + V3 * V3) / (2.f * V4));
}

void euler2d_flux(dfloat rho_i, dfloat rho_j, dfloat u_i, dfloat u_j,
                  dfloat v_i, dfloat v_j, dfloat E_i, dfloat E_j, dfloat beta_i,
                  dfloat beta_j, dfloat &FxS1, dfloat &FyS1, dfloat &FxS2,
                  dfloat &FyS2, dfloat &FxS3, dfloat &FyS3, dfloat &FxS4,
                  dfloat &FyS4)
{
#ifdef TESTING
/*
  const dfloat rholog = logmean(rho_i, rho_j);
  const dfloat uavg = avg(u_i, u_j);
  const dfloat vavg = avg(v_i, v_j);
  const dfloat vnavg = 2.f * (uavg * uavg + vavg * vavg) -
    0.5f * (u_i * u_i + u_j * u_j + v_i * v_i + v_j * v_j);
//    (avg(u_i * u_i, u_j * u_j) + avg(v_i * v_i, v_j * v_j));
  const dfloat beta_avg = avg(beta_i, beta_j);

  const dfloat pa = 0.25*(rho_i+rho_j)/beta_avg;
//  const dfloat pa = 0.5*(rho_i+rho_j)/(beta_i + beta_j);
  const dfloat f4aux =
    rholog / (2.f * (p_gamma - 1.f) * logmean(beta_i, beta_j)) + pa +
    .5f * rholog * vnavg;

  FxS1 = rholog * uavg;
  FyS1 = rholog * vavg;
  FxS2 = FxS1 * uavg + pa;
  FyS2 = FyS1 * uavg;
  FxS3 = FyS2;
  FyS3 = FyS1 * vavg + pa;
  FxS4 = f4aux * uavg;
  FyS4 = f4aux * vavg;
*/
  FxS1 = 1;
  FyS1 = 1;
  FxS2 = 2;
  FyS2 = 2;
  FxS3 = 3;
  FyS3 = 3;
  FxS4 = 4;
  FyS4 = 4;
#else

  const dfloat rholog = logmean(rho_i, rho_j);
  const dfloat rhoavg = avg(rho_i, rho_j);
  const dfloat uavg = avg(u_i, u_j);
  const dfloat vavg = avg(v_i, v_j);
  const dfloat vnavg = 2.f * (uavg * uavg + vavg * vavg) -
    (avg(u_i * u_i, u_j * u_j) + avg(v_i * v_i, v_j * v_j));
  const dfloat beta_avg = avg(beta_i, beta_j);

  const dfloat pa = rhoavg / (2.f * beta_avg);
  const dfloat f4aux =
    rholog / (2.f * (p_gamma - 1.f) * logmean(beta_i, beta_j)) + pa +
    .5f * rholog * vnavg;

  FxS1 = rholog * uavg;
  FyS1 = rholog * vavg;
  FxS2 = FxS1 * uavg + pa;
  FyS2 = FyS1 * uavg;
  FxS3 = FyS2;
  FyS3 = FyS1 * vavg + pa;
  FxS4 = f4aux * uavg;
  FyS4 = f4aux * vavg;
#endif

}

kernel void test_kernel_2d(const int K, dfloat *restrict Q, dfloat *restrict Qf,
                           dfloat *restrict rhsQ, dfloat *restrict rhsQf)
{

  for (int k = 0; k < K; ++k; outer0)
    {
      for (int i = 0; i < p_T; ++i; inner0)
        {
          if (i < p_Nq)
            {
              dfloat rho = Q[i + 0 * p_Nq + k * p_Nq * p_Nfields];
              dfloat rhou = Q[i + 1 * p_Nq + k * p_Nq * p_Nfields];
              dfloat rhov = Q[i + 2 * p_Nq + k * p_Nq * p_Nfields];
              dfloat E = Q[i + 3 * p_Nq + k * p_Nq * p_Nfields];
              if (k == 0 && i == 0)
                {
                  // printf("p_Nq = %d, p_Nfields = %d, K = %d\n",p_Nq,p_Nfields,K);
                  printf("Q(%d) = %16.16f, %16.16f, %16.16f, %16.16f\n", i, rho, rhou,
                         rhov, E);
                }
            }
        } // inner0
    }
  barrier(globalMemFence);

  for (int k = 0; k < K; ++k; outer0)
    {
      for (int i = 0; i < p_T; ++i; inner0)
        {
          if (i < p_Nq)
            {
              dfloat rho = rhsQ[i + 0 * p_Nq + k * p_Nq * p_Nfields];
              dfloat rhou = rhsQ[i + 1 * p_Nq + k * p_Nq * p_Nfields];
              dfloat rhov = rhsQ[i + 2 * p_Nq + k * p_Nq * p_Nfields];
              dfloat E = rhsQ[i + 3 * p_Nq + k * p_Nq * p_Nfields];
              if (k == 0 && i == 0)
                {
                  printf("Qv(%d) = %16.16f, %16.16f, %16.16f, %16.16f\n", i, rho, rhou,
                         rhov, E);
                }
            }
        } // inner0
    }
  barrier(globalMemFence);

  for (int k = 0; k < K; ++k; outer0)
    {
      for (int i = 0; i < p_T; ++i; inner0)
        {
          if (i < p_NfqNfaces)
            {
              int id = i + k * p_NfqNfaces * p_Nfields;
              int offset = p_NfqNfaces;
              dfloat rho = Qf[id + 0 * offset];
              dfloat rhou = Qf[id + 1 * offset];
              dfloat rhov = Qf[id + 2 * offset];
              dfloat E = Qf[id + 3 * offset];
              if (k == 0 && i == 0)
                {
                  printf("Qvf(%d) = %16.16f, %16.16f, %16.16f, %16.16f\n", i, rho, rhou,
                         rhov, E);
                }
            }
        } // inner0
    }   // outer0
}

//  =============== RK kernels ===============

kernel void euler_vol_2d(const int K,
                         const dfloat *restrict vgeo,
                         const dfloat *restrict vfgeo,                   
                         const dfloat *restrict nrJ, // ref elem normals
                         const dfloat *restrict nsJ, //
                         const dfloat *restrict Drq, const dfloat *restrict Dsq,
                         const dfloat *restrict VqLq,
                         const dfloat *restrict VfPq, const dfloat *restrict Q,
                         const dfloat *restrict Qf, dfloat *restrict rhsQ,
                         dfloat *restrict rhsQf)
{

  // loop over elements
  for (int k1 = 0; k1 < (K + p_KblkV - 1) / p_KblkV; ++k1; outer0)
    {

      shared dfloat srho[p_KblkV][p_Nq];
      shared dfloat srhou[p_KblkV][p_Nq];
      shared dfloat srhov[p_KblkV][p_Nq];
      shared dfloat sE[p_KblkV][p_Nq];

      // surface quadrature values
      // can reduce smem usage w/multiple reads and reusing?
      shared dfloat srhof[p_KblkV][p_NfqNfaces];
      shared dfloat srhouf[p_KblkV][p_NfqNfaces];
      shared dfloat srhovf[p_KblkV][p_NfqNfaces];
      shared dfloat sEf[p_KblkV][p_NfqNfaces];

      // geofacs
      shared dfloat sG[p_KblkV][p_Nvgeo];
      shared dfloat s_nrJ[p_Nfaces];
      shared dfloat s_nsJ[p_Nfaces];

shared int max_iter;
if(K <= (k1+1)*p_KblkV) {
  max_iter = K - (k1*p_KblkV);
} else {
  max_iter = p_KblkV;
}
#ifdef TESTING
      for (int k2 = 0; k2 < p_KblkV; ++k2; inner1)
        {
          for (int i = 0; i < p_T; ++i; inner0)
            {

              const int k = k1 * p_KblkV + k2;

              if (k < K)
                {

                  // load geometric factors into shared memory
                  int ii = i;
                  while (ii < p_Nvgeo)
                    {
                      // pick out first geofac in Nq list
                      sG[k2][ii] = vgeo[ii * p_Nq + k * p_Nq * p_Nvgeo];
                      ii += p_T;
                    }

                  // load reference normals
                  if (i < p_Nfaces)
                    {
                      s_nrJ[i] = nrJ[i * p_Nfq];
                      s_nsJ[i] = nsJ[i * p_Nfq];
                    }

                  // load p into shared memory for element k
                  // using rhsQ to store u(Pq*v)
                  if (i < p_Nq)
                    {
                      int id = i + k * p_Nq * p_Nfields;
                      srho[k2][i] = rhsQ[id];
                      id += p_Nq;
                      srhou[k2][i] = rhsQ[id];
                      id += p_Nq;
                      srhov[k2][i] = rhsQ[id];
                      id += p_Nq;
                      sE[k2][i] = rhsQ[id];
                    }

                  // load face values into smem
                  if (i < p_NfqNfaces)
                    {
                      int id = i + k * p_NfqNfaces * p_Nfields;
                      srhof[k2][i] = Qf[id + 0 * p_NfqNfaces];
                      srhouf[k2][i] = Qf[id + 1 * p_NfqNfaces];
                      srhovf[k2][i] = Qf[id + 2 * p_NfqNfaces];
                      sEf[k2][i] = Qf[id + 3 * p_NfqNfaces];
                    }
                }
            }
        }
#else
      for (int k2 = 0; k2 < p_KblkV; ++k2; inner1)
        {
          for (int i = 0; i < p_T; ++i; inner0)
            {

              const int k = k1 * p_KblkV + k2;

              if (k < K)
                {

                  // load geometric factors into shared memory
                  int ii = i;
                  while (ii < p_Nvgeo)
                    {
                      // pick out first geofac in Nq list
                      sG[k2][ii] = vgeo[ii * p_Nq + k * p_Nq * p_Nvgeo];
                      ii += p_T;
                    }

                  // load reference normals
                  if (i < p_Nfaces)
                    {
                      s_nrJ[i] = nrJ[i * p_Nfq];
                      s_nsJ[i] = nsJ[i * p_Nfq];
                    }

                  // load p into shared memory for element k
                  // using rhsQ to store u(Pq*v)
                  if (i < p_Nq)
                    {
                      int id = i + k * p_Nq * p_Nfields;
                      srho[k2][i] = rhsQ[id];
                      id += p_Nq;
                      srhou[k2][i] = rhsQ[id];
                      id += p_Nq;
                      srhov[k2][i] = rhsQ[id];
                      id += p_Nq;
                      sE[k2][i] = rhsQ[id];
                    }

                  // load face values into smem
                  if (i < p_NfqNfaces)
                    {
                      int id = i + k * p_NfqNfaces * p_Nfields;
                      srhof[k2][i] = Qf[id + 0 * p_NfqNfaces];
                      srhouf[k2][i] = Qf[id + 1 * p_NfqNfaces];
                      srhovf[k2][i] = Qf[id + 2 * p_NfqNfaces];
                      sEf[k2][i] = Qf[id + 3 * p_NfqNfaces];
                    }
                }
            }
        }
#endif
      barrier(localMemFence);

#define rxJ sG[k2][0]
#define ryJ sG[k2][1]
#define sxJ sG[k2][2]
#define syJ sG[k2][3]


#ifdef TESTING
      for (int k2 = 0; k2 < max_iter; ++k2; inner1)
        {
          for (int i = 0; i < p_T; ++i; inner0)
            {

              const int k = k1 * p_KblkV + k2;

                  if (i < p_Nq)
                    {
                      dfloat divF1 = 0.f;
                      dfloat divF2 = 0.f;
                      dfloat divF3 = 0.f;
                      dfloat divF4 = 0.f;

                      // apply Drq, Dsq
                      const dfloat rho_i = srho[k2][i];
                      const dfloat u_i = srhou[k2][i] / rho_i;
                      const dfloat v_i = srhov[k2][i] / rho_i;
                      const dfloat E_i = sE[k2][i];
                      const dfloat beta_i = beta(rho_i, u_i, v_i, E_i);
#if 0
                      if (k==0){
                        printf("rho,u,v,E,beta(i=%d) = %f, %f, %f, %f, %f\n",i,rho_i,u_i,v_i,E_i,beta_i);
                      }
#endif
                      for (int j = 0; j < p_Nq; ++j)
                        { // ILP

                          const int jid = i + j * p_Nq;
                          const dfloat Drq_ij = Drq[jid];
                          const dfloat Dsq_ij = Dsq[jid];

                          const dfloat rho_j = srho[k2][j];
                          const dfloat u_j = srhou[k2][j] / rho_j;
                          const dfloat v_j = srhov[k2][j] / rho_j;
                          const dfloat E_j = sE[k2][j];
                          const dfloat beta_j = beta(rho_j, u_j, v_j, E_j);
#if 0
                          if (k==0){
                            printf("rho,u,v,E,beta(%d) = %f, %f, %f, %f, %f\n",j,rho_j,u_j,v_j,E_j,beta_j);
                          }
#endif

                          dfloat FxS1, FyS1, FxS2, FyS2, FxS3, FyS3, FxS4, FyS4;
                          euler2d_flux(rho_i, rho_j, u_i, u_j, v_i, v_j, E_i, E_j, beta_i,
                                       beta_j, FxS1, FyS1, FxS2, FyS2, FxS3, FyS3, FxS4,
                                       FyS4);
#if 0
                          if (0){//(k==0 && i==0){
                            printf("xfluxes(j = %d) = %f, %f, %f, %f\n",j,FxS1,FxS2,FxS3,FxS4);
                            printf("yfluxes(j = %d) = %f, %f, %f, %f\n",j,FyS1,FyS2,FyS3,FyS4);
                          }
#endif

                          divF1 += Drq_ij * (FxS1 * rxJ + FyS1 * ryJ) +
                            Dsq_ij * (FxS1 * sxJ + FyS1 * syJ);
                          divF2 += Drq_ij * (FxS2 * rxJ + FyS2 * ryJ) +
                            Dsq_ij * (FxS2 * sxJ + FyS2 * syJ);
                          divF3 += Drq_ij * (FxS3 * rxJ + FyS3 * ryJ) +
                            Dsq_ij * (FxS3 * sxJ + FyS3 * syJ);
                          divF4 += Drq_ij * (FxS4 * rxJ + FyS4 * ryJ) +
                            Dsq_ij * (FxS4 * sxJ + FyS4 * syJ);
                        }

                      // apply VqLq (keep rho_i, etc from before)
                      for (int j = 0; j < p_NfqNfaces; ++j)
                        {
                          const dfloat VqLq_ij = .5f * VqLq[i + j * p_Nq];
                          // printf("VqLq(%d,%d) = %f\n",i,j,VqLq_ij);

                          const dfloat rho_j = srhof[k2][j];
                          const dfloat u_j = srhouf[k2][j] / rho_j;
                          const dfloat v_j = srhovf[k2][j] / rho_j;
                          const dfloat E_j = sEf[k2][j];
                          const dfloat beta_j = beta(rho_j, u_j, v_j, E_j);

                          dfloat FxS1, FyS1, FxS2, FyS2, FxS3, FyS3, FxS4, FyS4;
                          euler2d_flux(rho_i, rho_j, u_i, u_j, v_i, v_j, E_i, E_j, beta_i,
                                       beta_j, FxS1, FyS1, FxS2, FyS2, FxS3, FyS3, FxS4,
                                       FyS4);

                          const int f = j / p_Nfq;
                          const dfloat nrJf = s_nrJ[f];
                          const dfloat nsJf = s_nsJ[f];

                          const dfloat F1 = ((FxS1 * rxJ + FyS1 * ryJ) * nrJf +
                                             (FxS1 * sxJ + FyS1 * syJ) * nsJf);
                          const dfloat F2 = ((FxS2 * rxJ + FyS2 * ryJ) * nrJf +
                                             (FxS2 * sxJ + FyS2 * syJ) * nsJf);
                          const dfloat F3 = ((FxS3 * rxJ + FyS3 * ryJ) * nrJf +
                                             (FxS3 * sxJ + FyS3 * syJ) * nsJf);
                          const dfloat F4 = ((FxS4 * rxJ + FyS4 * ryJ) * nrJf +
                                             (FxS4 * sxJ + FyS4 * syJ) * nsJf);
                          divF1 += VqLq_ij * F1;
                          divF2 += VqLq_ij * F2;
                          divF3 += VqLq_ij * F3;
                          divF4 += VqLq_ij * F4;
                        }

#if 0
                      if (k == 0)
                        {
                          printf("divF(%d,%d): %16.16f, %16.16f, %16.16f, %16.16f\n", i, k,
                                 divF1, divF2, divF3, divF4);
                          // printf("divF(%d,%d): %g, %g, %g,
                          // %g\n",i,k,divF1,divF2,divF3,divF4);
                        }
#endif

                      int id = i + k * p_Nfields * p_Nq;
                      rhsQ[id] = divF1;
                      id += p_Nq;
                      rhsQ[id] = divF2;
                      id += p_Nq;
                      rhsQ[id] = divF3;
                      id += p_Nq;
                      rhsQ[id] = divF4;
                    }

                  // now apply VfPq
                  if (i < p_NfqNfaces)
                    {

                      dfloat divF1 = 0.f;
                      dfloat divF2 = 0.f;
                      dfloat divF3 = 0.f;
                      dfloat divF4 = 0.f;

                      // redefine rho_i, etc...
                      const dfloat rho_i = srhof[k2][i];
                      const dfloat u_i = srhouf[k2][i] / rho_i;
                      const dfloat v_i = srhovf[k2][i] / rho_i;
                      const dfloat E_i = sEf[k2][i];
                      const dfloat beta_i = beta(rho_i, u_i, v_i, E_i);

                      const int f = i / p_Nfq;
                      const dfloat nrJf = s_nrJ[f];
                      const dfloat nsJf = s_nsJ[f];

                      for (int j = 0; j < p_Nq; ++j)
                        {
                          const dfloat VfPq_ij = -.5f * VfPq[i + j * p_NfqNfaces];

                          const dfloat rho_j = srho[k2][j];
                          const dfloat u_j = srhou[k2][j] / rho_j;
                          const dfloat v_j = srhov[k2][j] / rho_j;
                          const dfloat E_j = sE[k2][j];
                          const dfloat beta_j = beta(rho_j, u_j, v_j, E_j);

                          dfloat FxS1, FyS1, FxS2, FyS2, FxS3, FyS3, FxS4, FyS4;
                          euler2d_flux(rho_i, rho_j, u_i, u_j, v_i, v_j, E_i, E_j, beta_i,
                                       beta_j, FxS1, FyS1, FxS2, FyS2, FxS3, FyS3, FxS4,
                                       FyS4);

                          const dfloat F1 = ((FxS1 * rxJ + FyS1 * ryJ) * nrJf +
                                             (FxS1 * sxJ + FyS1 * syJ) * nsJf);
                          const dfloat F2 = ((FxS2 * rxJ + FyS2 * ryJ) * nrJf +
                                             (FxS2 * sxJ + FyS2 * syJ) * nsJf);
                          const dfloat F3 = ((FxS3 * rxJ + FyS3 * ryJ) * nrJf +
                                             (FxS3 * sxJ + FyS3 * syJ) * nsJf);
                          const dfloat F4 = ((FxS4 * rxJ + FyS4 * ryJ) * nrJf +
                                             (FxS4 * sxJ + FyS4 * syJ) * nsJf);

                          divF1 += VfPq_ij * F1;
                          divF2 += VfPq_ij * F2;
                          divF3 += VfPq_ij * F3;
                          divF4 += VfPq_ij * F4;
                        }

                      // if (k==0){
                      //              printf("surf divF(%d,%d): %16.16f, %16.16f, %16.16f,
                      //%16.16f\n",i,k,divF1,divF2,divF3,divF4);
                      //            }

                      int idf = i + k * p_Nfields * p_NfqNfaces;
                      rhsQf[idf] = divF1;
                      idf += p_NfqNfaces;
                      rhsQf[idf] = divF2;
                      idf += p_NfqNfaces;
                      rhsQf[idf] = divF3;
                      idf += p_NfqNfaces;
                      rhsQf[idf] = divF4;

                    } // if i < p_NfqNfaces

            }   // inner0
        }     // inner1
#else
      for (int k2 = 0; k2 < p_KblkV; ++k2; inner1)
        {
          for (int i = 0; i < p_T; ++i; inner0)
            {

              const int k = k1 * p_KblkV + k2;

              if (k < K)
                {

                  if (i < p_Nq)
                    {
                      dfloat divF1 = 0.f;
                      dfloat divF2 = 0.f;
                      dfloat divF3 = 0.f;
                      dfloat divF4 = 0.f;

                      // apply Drq, Dsq
                      const dfloat rho_i = srho[k2][i];
                      const dfloat u_i = srhou[k2][i] / rho_i;
                      const dfloat v_i = srhov[k2][i] / rho_i;
                      const dfloat E_i = sE[k2][i];
                      const dfloat beta_i = beta(rho_i, u_i, v_i, E_i);
#if 0
                      if (k==0){
                        printf("rho,u,v,E,beta(i=%d) = %f, %f, %f, %f, %f\n",i,rho_i,u_i,v_i,E_i,beta_i);
                      }
#endif
                      for (int j = 0; j < p_Nq; ++j)
                        { // ILP

                          const int jid = i + j * p_Nq;
                          const dfloat Drq_ij = Drq[jid];
                          const dfloat Dsq_ij = Dsq[jid];

                          const dfloat rho_j = srho[k2][j];
                          const dfloat u_j = srhou[k2][j] / rho_j;
                          const dfloat v_j = srhov[k2][j] / rho_j;
                          const dfloat E_j = sE[k2][j];
                          const dfloat beta_j = beta(rho_j, u_j, v_j, E_j);
#if 0
                          if (k==0){
                            printf("rho,u,v,E,beta(%d) = %f, %f, %f, %f, %f\n",j,rho_j,u_j,v_j,E_j,beta_j);
                          }
#endif

                          dfloat FxS1, FyS1, FxS2, FyS2, FxS3, FyS3, FxS4, FyS4;
                          euler2d_flux(rho_i, rho_j, u_i, u_j, v_i, v_j, E_i, E_j, beta_i,
                                       beta_j, FxS1, FyS1, FxS2, FyS2, FxS3, FyS3, FxS4,
                                       FyS4);
#if 0
                          if (0){//(k==0 && i==0){
                            printf("xfluxes(j = %d) = %f, %f, %f, %f\n",j,FxS1,FxS2,FxS3,FxS4);
                            printf("yfluxes(j = %d) = %f, %f, %f, %f\n",j,FyS1,FyS2,FyS3,FyS4);
                          }
#endif

                          divF1 += Drq_ij * (FxS1 * rxJ + FyS1 * ryJ) +
                            Dsq_ij * (FxS1 * sxJ + FyS1 * syJ);
                          divF2 += Drq_ij * (FxS2 * rxJ + FyS2 * ryJ) +
                            Dsq_ij * (FxS2 * sxJ + FyS2 * syJ);
                          divF3 += Drq_ij * (FxS3 * rxJ + FyS3 * ryJ) +
                            Dsq_ij * (FxS3 * sxJ + FyS3 * syJ);
                          divF4 += Drq_ij * (FxS4 * rxJ + FyS4 * ryJ) +
                            Dsq_ij * (FxS4 * sxJ + FyS4 * syJ);
                        }

                      // apply VqLq (keep rho_i, etc from before)
                      for (int j = 0; j < p_NfqNfaces; ++j)
                        {
                          const dfloat VqLq_ij = .5f * VqLq[i + j * p_Nq];
                          // printf("VqLq(%d,%d) = %f\n",i,j,VqLq_ij);

                          const dfloat rho_j = srhof[k2][j];
                          const dfloat u_j = srhouf[k2][j] / rho_j;
                          const dfloat v_j = srhovf[k2][j] / rho_j;
                          const dfloat E_j = sEf[k2][j];
                          const dfloat beta_j = beta(rho_j, u_j, v_j, E_j);

                          dfloat FxS1, FyS1, FxS2, FyS2, FxS3, FyS3, FxS4, FyS4;
                          euler2d_flux(rho_i, rho_j, u_i, u_j, v_i, v_j, E_i, E_j, beta_i,
                                       beta_j, FxS1, FyS1, FxS2, FyS2, FxS3, FyS3, FxS4,
                                       FyS4);

                          const int f = j / p_Nfq;
                          const dfloat nrJf = s_nrJ[f];
                          const dfloat nsJf = s_nsJ[f];

                          const dfloat F1 = ((FxS1 * rxJ + FyS1 * ryJ) * nrJf +
                                             (FxS1 * sxJ + FyS1 * syJ) * nsJf);
                          const dfloat F2 = ((FxS2 * rxJ + FyS2 * ryJ) * nrJf +
                                             (FxS2 * sxJ + FyS2 * syJ) * nsJf);
                          const dfloat F3 = ((FxS3 * rxJ + FyS3 * ryJ) * nrJf +
                                             (FxS3 * sxJ + FyS3 * syJ) * nsJf);
                          const dfloat F4 = ((FxS4 * rxJ + FyS4 * ryJ) * nrJf +
                                             (FxS4 * sxJ + FyS4 * syJ) * nsJf);
                          divF1 += VqLq_ij * F1;
                          divF2 += VqLq_ij * F2;
                          divF3 += VqLq_ij * F3;
                          divF4 += VqLq_ij * F4;
                        }

#if 0
                      if (k == 0)
                        {
                          printf("divF(%d,%d): %16.16f, %16.16f, %16.16f, %16.16f\n", i, k,
                                 divF1, divF2, divF3, divF4);
                          // printf("divF(%d,%d): %g, %g, %g,
                          // %g\n",i,k,divF1,divF2,divF3,divF4);
                        }
#endif

                      int id = i + k * p_Nfields * p_Nq;
                      rhsQ[id] = divF1;
                      id += p_Nq;
                      rhsQ[id] = divF2;
                      id += p_Nq;
                      rhsQ[id] = divF3;
                      id += p_Nq;
                      rhsQ[id] = divF4;
                    }

                  // now apply VfPq
                  if (i < p_NfqNfaces)
                    {

                      dfloat divF1 = 0.f;
                      dfloat divF2 = 0.f;
                      dfloat divF3 = 0.f;
                      dfloat divF4 = 0.f;

                      // redefine rho_i, etc...
                      const dfloat rho_i = srhof[k2][i];
                      const dfloat u_i = srhouf[k2][i] / rho_i;
                      const dfloat v_i = srhovf[k2][i] / rho_i;
                      const dfloat E_i = sEf[k2][i];
                      const dfloat beta_i = beta(rho_i, u_i, v_i, E_i);

                      const int f = i / p_Nfq;
                      const dfloat nrJf = s_nrJ[f];
                      const dfloat nsJf = s_nsJ[f];

                      for (int j = 0; j < p_Nq; ++j)
                        {
                          const dfloat VfPq_ij = -.5f * VfPq[i + j * p_NfqNfaces];

                          const dfloat rho_j = srho[k2][j];
                          const dfloat u_j = srhou[k2][j] / rho_j;
                          const dfloat v_j = srhov[k2][j] / rho_j;
                          const dfloat E_j = sE[k2][j];
                          const dfloat beta_j = beta(rho_j, u_j, v_j, E_j);

                          dfloat FxS1, FyS1, FxS2, FyS2, FxS3, FyS3, FxS4, FyS4;
                          euler2d_flux(rho_i, rho_j, u_i, u_j, v_i, v_j, E_i, E_j, beta_i,
                                       beta_j, FxS1, FyS1, FxS2, FyS2, FxS3, FyS3, FxS4,
                                       FyS4);

                          const dfloat F1 = ((FxS1 * rxJ + FyS1 * ryJ) * nrJf +
                                             (FxS1 * sxJ + FyS1 * syJ) * nsJf);
                          const dfloat F2 = ((FxS2 * rxJ + FyS2 * ryJ) * nrJf +
                                             (FxS2 * sxJ + FyS2 * syJ) * nsJf);
                          const dfloat F3 = ((FxS3 * rxJ + FyS3 * ryJ) * nrJf +
                                             (FxS3 * sxJ + FyS3 * syJ) * nsJf);
                          const dfloat F4 = ((FxS4 * rxJ + FyS4 * ryJ) * nrJf +
                                             (FxS4 * sxJ + FyS4 * syJ) * nsJf);

                          divF1 += VfPq_ij * F1;
                          divF2 += VfPq_ij * F2;
                          divF3 += VfPq_ij * F3;
                          divF4 += VfPq_ij * F4;
                        }

                      // if (k==0){
                      //              printf("surf divF(%d,%d): %16.16f, %16.16f, %16.16f,
                      //%16.16f\n",i,k,divF1,divF2,divF3,divF4);
                      //            }

                      int idf = i + k * p_Nfields * p_NfqNfaces;
                      rhsQf[idf] = divF1;
                      idf += p_NfqNfaces;
                      rhsQf[idf] = divF2;
                      idf += p_NfqNfaces;
                      rhsQf[idf] = divF3;
                      idf += p_NfqNfaces;
                      rhsQf[idf] = divF4;

                    } // if i < p_NfqNfaces

                } // k < K
            }   // inner0
        }     // inner1
#endif
    }
}

kernel void euler_vol_2d_curved(const int K,
                                const dfloat *restrict vgeo,
                                const dfloat *restrict vfgeo,                    
                                const dfloat *restrict nrJ, // ref elem normals
                                const dfloat *restrict nsJ, //
                                const dfloat *restrict Drq, const dfloat *restrict Dsq,
                                const dfloat *restrict VqLq,
                                const dfloat *restrict VfPq, const dfloat *restrict Q,
                                const dfloat *restrict Qf, dfloat *restrict rhsQ,
                                dfloat *restrict rhsQf)
{

  // loop over elements
  for (int k1 = 0; k1 < (K + p_KblkV - 1) / p_KblkV; ++k1; outer0)
    {

      shared dfloat srho[p_KblkV][p_Nq];
      shared dfloat srhou[p_KblkV][p_Nq];
      shared dfloat srhov[p_KblkV][p_Nq];
      shared dfloat sE[p_KblkV][p_Nq];

      // surface quadrature values
      // can reduce smem usage w/multiple reads and reusing?
      shared dfloat srhof[p_KblkV][p_NfqNfaces];
      shared dfloat srhouf[p_KblkV][p_NfqNfaces];
      shared dfloat srhovf[p_KblkV][p_NfqNfaces];
      shared dfloat sEf[p_KblkV][p_NfqNfaces];

      // geofacs
      shared dfloat s_nrJ[p_Nfaces];
      shared dfloat s_nsJ[p_Nfaces];

shared int min_iter;
shared int min_p_T_p_Nq;
shared int min_p_T_p_NfqNfaces;
if(K <= (k1+1)*p_KblkV) {
  min_iter = K - (k1 * p_KblkV);
} else {
  min_iter = p_KblkV;
}
if(p_T <= p_Nq) {
  min_p_T_p_Nq = p_T;
}else{
  min_p_T_p_Nq = p_Nq;
}
if(p_T <= p_NfqNfaces) {
  min_p_T_p_NfqNfaces = p_T;
}else{
  min_p_T_p_NfqNfaces = p_NfqNfaces;
}

      for (int k2 = 0; k2 < p_KblkV; ++k2; inner1)
        {
          for (int i = 0; i < p_T; ++i; inner0)
            {

              const int k = k1 * p_KblkV + k2;

              if (k < K)
                {

                  // load reference normals
                  if (i < p_Nfaces)
                    {
                      s_nrJ[i] = nrJ[i * p_Nfq];
                      s_nsJ[i] = nsJ[i * p_Nfq];
                    }

                  // load p into shared memory for element k
                  // using rhsQ to store u(Pq*v)
                  if (i < p_Nq)
                    {
                      int id = i + k * p_Nq * p_Nfields;
                      srho[k2][i] = rhsQ[id];
                      id += p_Nq;
                      srhou[k2][i] = rhsQ[id];
                      id += p_Nq;
                      srhov[k2][i] = rhsQ[id];
                      id += p_Nq;
                      sE[k2][i] = rhsQ[id];
                    }

                  // load face values into smem
                  if (i < p_NfqNfaces)
                    {
                      int id = i + k * p_NfqNfaces * p_Nfields;
                      srhof[k2][i] = Qf[id + 0 * p_NfqNfaces];
                      srhouf[k2][i] = Qf[id + 1 * p_NfqNfaces];
                      srhovf[k2][i] = Qf[id + 2 * p_NfqNfaces];
                      sEf[k2][i] = Qf[id + 3 * p_NfqNfaces];
                    }
                }
            }
        }
      barrier(localMemFence);
/*
shared int min_iter;
shared int min_p_T_p_Nq;
shared int min_p_T_p_NfqNfaces;
if(K <= (k1+1)*p_KblkV) {
  min_iter = K - (k1 * p_KblkV);
} else {
  min_iter = p_KblkV;
}
if(p_T <= p_Nq) {
  min_p_T_p_Nq = p_T;
}else{
  min_p_T_p_Nq = p_Nq;
}
if(p_T <= p_NfqNfaces) {
  min_p_T_p_NfqNfaces = p_T;
}else{
  min_p_T_p_NfqNfaces = p_NfqNfaces;
}
*/
#ifndef TESTING
      for (int k2 = 0; k2 < min_iter; ++k2; inner1)
        {
          const int k = k1 * p_KblkV + k2;
          for (int i = 0; i < min_p_T_p_Nq; ++i; inner0)
            {
                dfloat divF1 = 0.f;
                dfloat divF2 = 0.f;
                dfloat divF3 = 0.f;
                dfloat divF4 = 0.f;

                // apply Drq, Dsq
                const dfloat rho_i = srho[k2][i];
                const dfloat u_i = srhou[k2][i] / rho_i;
                const dfloat v_i = srhov[k2][i] / rho_i;
                const dfloat E_i = sE[k2][i];
                const dfloat beta_i = beta(rho_i, u_i, v_i, E_i);
/*
                if (k==0){
                  printf("rho,u,v,E,beta(i=%d) = %f, %f, %f, %f, %f\n",i,rho_i,u_i,v_i,E_i,beta_i);
                }           
*/
                const int gidi = i + k * p_Nq * p_Nvgeo;
                const dfloat rxJi = vgeo[gidi];
                const dfloat ryJi = vgeo[gidi + p_Nq];
                const dfloat sxJi = vgeo[gidi + 2*p_Nq];
                const dfloat syJi = vgeo[gidi + 3*p_Nq];
            
                for (int j = 0; j < p_Nq; ++j)
                  { // ILP

                    const int jid = i + j * p_Nq;
                    const dfloat Drq_ij = Drq[jid];
                    const dfloat Dsq_ij = Dsq[jid];

                    const dfloat rho_j = srho[k2][j];
                    const dfloat u_j = srhou[k2][j] / rho_j;
                    const dfloat v_j = srhov[k2][j] / rho_j;
                    const dfloat E_j = sE[k2][j];
                    const dfloat beta_j = beta(rho_j, u_j, v_j, E_j);
/*
                    if (k==0){
                      printf("rho,u,v,E,beta(%d) = %f, %f, %f, %f, %f\n",j,rho_j,u_j,v_j,E_j,beta_j);
                    }
*/
              
                    const int gidj = j + k * p_Nq * p_Nvgeo;
                    const dfloat rxJj = vgeo[gidj];
                    const dfloat ryJj = vgeo[gidj + p_Nq];
                    const dfloat sxJj = vgeo[gidj + 2*p_Nq];
                    const dfloat syJj = vgeo[gidj + 3*p_Nq];

                    const dfloat rxJa = .5f*(rxJi+rxJj);
                    const dfloat sxJa = .5f*(sxJi+sxJj);
                    const dfloat ryJa = .5f*(ryJi+ryJj);
                    const dfloat syJa = .5f*(syJi+syJj);        

                    dfloat FxS1, FyS1, FxS2, FyS2, FxS3, FyS3, FxS4, FyS4;
                    euler2d_flux(rho_i, rho_j, u_i, u_j, v_i, v_j, E_i, E_j, beta_i,
                                 beta_j, FxS1, FyS1, FxS2, FyS2, FxS3, FyS3, FxS4,
                                 FyS4);
/*
                    if (0){//(k==0 && i==0){
                      printf("xfluxes(j = %d) = %f, %f, %f, %f\n",j,FxS1,FxS2,FxS3,FxS4);
                      printf("yfluxes(j = %d) = %f, %f, %f, %f\n",j,FyS1,FyS2,FyS3,FyS4);
                    }
*/

                    divF1 += Drq_ij * (FxS1 * rxJa + FyS1 * ryJa) +
                      Dsq_ij * (FxS1 * sxJa + FyS1 * syJa);
                    divF2 += Drq_ij * (FxS2 * rxJa + FyS2 * ryJa) +
                      Dsq_ij * (FxS2 * sxJa + FyS2 * syJa);
                    divF3 += Drq_ij * (FxS3 * rxJa + FyS3 * ryJa) +
                      Dsq_ij * (FxS3 * sxJa + FyS3 * syJa);
                    divF4 += Drq_ij * (FxS4 * rxJa + FyS4 * ryJa) +
                      Dsq_ij * (FxS4 * sxJa + FyS4 * syJa);
                  }

                // apply VqLq (keep rho_i, etc from before)
                for (int j = 0; j < p_NfqNfaces; ++j)
                  {
                    const dfloat VqLq_ij = .5f * VqLq[i + j * p_Nq];
                    // printf("VqLq(%d,%d) = %f\n",i,j,VqLq_ij);

                    const dfloat rho_j = srhof[k2][j];
                    const dfloat u_j = srhouf[k2][j] / rho_j;
                    const dfloat v_j = srhovf[k2][j] / rho_j;
                    const dfloat E_j = sEf[k2][j];
                    const dfloat beta_j = beta(rho_j, u_j, v_j, E_j);

                    dfloat FxS1, FyS1, FxS2, FyS2, FxS3, FyS3, FxS4, FyS4;
                    euler2d_flux(rho_i, rho_j, u_i, u_j, v_i, v_j, E_i, E_j, beta_i,
                                 beta_j, FxS1, FyS1, FxS2, FyS2, FxS3, FyS3, FxS4,
                                 FyS4);

                    const int f = j / p_Nfq;
                    const dfloat nrJf = s_nrJ[f];
                    const dfloat nsJf = s_nsJ[f];

                    const int gidj = j + k * p_NfqNfaces * p_Nvgeo;
                    const dfloat rxJj = vfgeo[gidj];
                    const dfloat ryJj = vfgeo[gidj + p_NfqNfaces];
                    const dfloat sxJj = vfgeo[gidj + 2*p_NfqNfaces];
                    const dfloat syJj = vfgeo[gidj + 3*p_NfqNfaces];

                    const dfloat rxJa = .5f*(rxJi+rxJj);
                    const dfloat sxJa = .5f*(sxJi+sxJj);
                    const dfloat ryJa = .5f*(ryJi+ryJj);
                    const dfloat syJa = .5f*(syJi+syJj);                

                    const dfloat F1 = ((FxS1 * rxJa + FyS1 * ryJa) * nrJf +
                                       (FxS1 * sxJa + FyS1 * syJa) * nsJf);
                    const dfloat F2 = ((FxS2 * rxJa + FyS2 * ryJa) * nrJf +
                                       (FxS2 * sxJa + FyS2 * syJa) * nsJf);
                    const dfloat F3 = ((FxS3 * rxJa + FyS3 * ryJa) * nrJf +
                                       (FxS3 * sxJa + FyS3 * syJa) * nsJf);
                    const dfloat F4 = ((FxS4 * rxJa + FyS4 * ryJa) * nrJf +
                                       (FxS4 * sxJa + FyS4 * syJa) * nsJf);
                    divF1 += VqLq_ij * F1;
                    divF2 += VqLq_ij * F2;
                    divF3 += VqLq_ij * F3;
                    divF4 += VqLq_ij * F4;
                  }

/*
                if (k == 0)
                  {
                    printf("divF(%d,%d): %16.16f, %16.16f, %16.16f, %16.16f\n", i, k,
                           divF1, divF2, divF3, divF4);
                    // printf("divF(%d,%d): %g, %g, %g,
                    // %g\n",i,k,divF1,divF2,divF3,divF4);
                  }
*/

                int id = i + k * p_Nfields * p_Nq;
                rhsQ[id] = divF1;
                id += p_Nq;
                rhsQ[id] = divF2;
                id += p_Nq;
                rhsQ[id] = divF3;
                id += p_Nq;
                rhsQ[id] = divF4;
            } // inner0
          for (int i = 0; i < min_p_T_p_NfqNfaces; ++i; inner2)
            {
              dfloat divF1 = 0.f;
              dfloat divF2 = 0.f;
              dfloat divF3 = 0.f;
              dfloat divF4 = 0.f;

              // redefine rho_i, etc...
              const dfloat rho_i = srhof[k2][i];
              const dfloat u_i = srhouf[k2][i] / rho_i;
              const dfloat v_i = srhovf[k2][i] / rho_i;
              const dfloat E_i = sEf[k2][i];
              const dfloat beta_i = beta(rho_i, u_i, v_i, E_i);

              const int f = i / p_Nfq;
              const dfloat nrJf = s_nrJ[f];
              const dfloat nsJf = s_nsJ[f];

              const int gidi = i + k * p_NfqNfaces * p_Nvgeo;
              const dfloat rxJi = vfgeo[gidi];
              const dfloat ryJi = vfgeo[gidi + p_NfqNfaces];
              const dfloat sxJi = vfgeo[gidi + 2*p_NfqNfaces];
              const dfloat syJi = vfgeo[gidi + 3*p_NfqNfaces];      

              for (int j = 0; j < p_Nq; ++j)
                {
                  const dfloat VfPq_ij = -.5f * VfPq[i + j * p_NfqNfaces];

                  const dfloat rho_j = srho[k2][j];
                  const dfloat u_j = srhou[k2][j] / rho_j;
                  const dfloat v_j = srhov[k2][j] / rho_j;
                  const dfloat E_j = sE[k2][j];
                  const dfloat beta_j = beta(rho_j, u_j, v_j, E_j);

                  dfloat FxS1, FyS1, FxS2, FyS2, FxS3, FyS3, FxS4, FyS4;
                  euler2d_flux(rho_i, rho_j, u_i, u_j, v_i, v_j, E_i, E_j, beta_i,
                               beta_j, FxS1, FyS1, FxS2, FyS2, FxS3, FyS3, FxS4,
                               FyS4);

                  const int gidj = j + k * p_Nq * p_Nvgeo;
                  const dfloat rxJj = vgeo[gidj];
                  const dfloat ryJj = vgeo[gidj + p_Nq];
                  const dfloat sxJj = vgeo[gidj + 2*p_Nq];
                  const dfloat syJj = vgeo[gidj + 3*p_Nq];
              
                  const dfloat rxJa = .5f*(rxJi+rxJj);
                  const dfloat sxJa = .5f*(sxJi+sxJj);
                  const dfloat ryJa = .5f*(ryJi+ryJj);
                  const dfloat syJa = .5f*(syJi+syJj);                

              
                  const dfloat F1 = ((FxS1 * rxJa + FyS1 * ryJa) * nrJf +
                                     (FxS1 * sxJa + FyS1 * syJa) * nsJf);
                  const dfloat F2 = ((FxS2 * rxJa + FyS2 * ryJa) * nrJf +
                                     (FxS2 * sxJa + FyS2 * syJa) * nsJf);
                  const dfloat F3 = ((FxS3 * rxJa + FyS3 * ryJa) * nrJf +
                                     (FxS3 * sxJa + FyS3 * syJa) * nsJf);
                  const dfloat F4 = ((FxS4 * rxJa + FyS4 * ryJa) * nrJf +
                                     (FxS4 * sxJa + FyS4 * syJa) * nsJf);

                  divF1 += VfPq_ij * F1;
                  divF2 += VfPq_ij * F2;
                  divF3 += VfPq_ij * F3;
                  divF4 += VfPq_ij * F4;
                }

              // if (k==0){
              //              printf("surf divF(%d,%d): %16.16f, %16.16f, %16.16f,
              //%16.16f\n",i,k,divF1,divF2,divF3,divF4);
              //            }

              int idf = i + k * p_Nfields * p_NfqNfaces;
              rhsQf[idf] = divF1;
              idf += p_NfqNfaces;
              rhsQf[idf] = divF2;
              idf += p_NfqNfaces;
              rhsQf[idf] = divF3;
              idf += p_NfqNfaces;
              rhsQf[idf] = divF4;
            } // inner2
        } // inner1
#else
      for (int k2 = 0; k2 < p_KblkV; ++k2; inner1)
        {
          for (int i = 0; i < p_T; ++i; inner0)
            {

              const int k = k1 * p_KblkV + k2;

              if (k < K)
                {

                  if (i < p_Nq)
                    {
                      dfloat divF1 = 0.f;
                      dfloat divF2 = 0.f;
                      dfloat divF3 = 0.f;
                      dfloat divF4 = 0.f;

                      // apply Drq, Dsq
                      const dfloat rho_i = srho[k2][i];
                      const dfloat u_i = srhou[k2][i] / rho_i;
                      const dfloat v_i = srhov[k2][i] / rho_i;
                      const dfloat E_i = sE[k2][i];
                      const dfloat beta_i = beta(rho_i, u_i, v_i, E_i);
#if 0
                      if (k==0){
                        printf("rho,u,v,E,beta(i=%d) = %f, %f, %f, %f, %f\n",i,rho_i,u_i,v_i,E_i,beta_i);
                      }     
#endif

                      const int gidi = i + k * p_Nq * p_Nvgeo;
                      const dfloat rxJi = vgeo[gidi];
                      const dfloat ryJi = vgeo[gidi + p_Nq];
                      const dfloat sxJi = vgeo[gidi + 2*p_Nq];
                      const dfloat syJi = vgeo[gidi + 3*p_Nq];
            
                      for (int j = 0; j < p_Nq; ++j)
                        { // ILP

                          const int jid = i + j * p_Nq;
                          const dfloat Drq_ij = Drq[jid];
                          const dfloat Dsq_ij = Dsq[jid];

                          const dfloat rho_j = srho[k2][j];
                          const dfloat u_j = srhou[k2][j] / rho_j;
                          const dfloat v_j = srhov[k2][j] / rho_j;
                          const dfloat E_j = sE[k2][j];
                          const dfloat beta_j = beta(rho_j, u_j, v_j, E_j);
#if 0
                          if (k==0){
                            printf("rho,u,v,E,beta(%d) = %f, %f, %f, %f, %f\n",j,rho_j,u_j,v_j,E_j,beta_j);
                          }
#endif
              
                          const int gidj = j + k * p_Nq * p_Nvgeo;
                          const dfloat rxJj = vgeo[gidj];
                          const dfloat ryJj = vgeo[gidj + p_Nq];
                          const dfloat sxJj = vgeo[gidj + 2*p_Nq];
                          const dfloat syJj = vgeo[gidj + 3*p_Nq];

                          const dfloat rxJa = .5f*(rxJi+rxJj);
                          const dfloat sxJa = .5f*(sxJi+sxJj);
                          const dfloat ryJa = .5f*(ryJi+ryJj);
                          const dfloat syJa = .5f*(syJi+syJj);        

                          dfloat FxS1, FyS1, FxS2, FyS2, FxS3, FyS3, FxS4, FyS4;
                          euler2d_flux(rho_i, rho_j, u_i, u_j, v_i, v_j, E_i, E_j, beta_i,
                                       beta_j, FxS1, FyS1, FxS2, FyS2, FxS3, FyS3, FxS4,
                                       FyS4);
#if 0
                          if (0){//(k==0 && i==0){
                            printf("xfluxes(j = %d) = %f, %f, %f, %f\n",j,FxS1,FxS2,FxS3,FxS4);
                            printf("yfluxes(j = %d) = %f, %f, %f, %f\n",j,FyS1,FyS2,FyS3,FyS4);
                          }
#endif

                          divF1 += Drq_ij * (FxS1 * rxJa + FyS1 * ryJa) +
                            Dsq_ij * (FxS1 * sxJa + FyS1 * syJa);
                          divF2 += Drq_ij * (FxS2 * rxJa + FyS2 * ryJa) +
                            Dsq_ij * (FxS2 * sxJa + FyS2 * syJa);
                          divF3 += Drq_ij * (FxS3 * rxJa + FyS3 * ryJa) +
                            Dsq_ij * (FxS3 * sxJa + FyS3 * syJa);
                          divF4 += Drq_ij * (FxS4 * rxJa + FyS4 * ryJa) +
                            Dsq_ij * (FxS4 * sxJa + FyS4 * syJa);
                        }

                      // apply VqLq (keep rho_i, etc from before)
                      for (int j = 0; j < p_NfqNfaces; ++j)
                        {
                          const dfloat VqLq_ij = .5f * VqLq[i + j * p_Nq];
                          // printf("VqLq(%d,%d) = %f\n",i,j,VqLq_ij);

                          const dfloat rho_j = srhof[k2][j];
                          const dfloat u_j = srhouf[k2][j] / rho_j;
                          const dfloat v_j = srhovf[k2][j] / rho_j;
                          const dfloat E_j = sEf[k2][j];
                          const dfloat beta_j = beta(rho_j, u_j, v_j, E_j);

                          dfloat FxS1, FyS1, FxS2, FyS2, FxS3, FyS3, FxS4, FyS4;
                          euler2d_flux(rho_i, rho_j, u_i, u_j, v_i, v_j, E_i, E_j, beta_i,
                                       beta_j, FxS1, FyS1, FxS2, FyS2, FxS3, FyS3, FxS4,
                                       FyS4);

                          const int f = j / p_Nfq;
                          const dfloat nrJf = s_nrJ[f];
                          const dfloat nsJf = s_nsJ[f];

                          const int gidj = j + k * p_NfqNfaces * p_Nvgeo;
                          const dfloat rxJj = vfgeo[gidj];
                          const dfloat ryJj = vfgeo[gidj + p_NfqNfaces];
                          const dfloat sxJj = vfgeo[gidj + 2*p_NfqNfaces];
                          const dfloat syJj = vfgeo[gidj + 3*p_NfqNfaces];

                          const dfloat rxJa = .5f*(rxJi+rxJj);
                          const dfloat sxJa = .5f*(sxJi+sxJj);
                          const dfloat ryJa = .5f*(ryJi+ryJj);
                          const dfloat syJa = .5f*(syJi+syJj);                

                          const dfloat F1 = ((FxS1 * rxJa + FyS1 * ryJa) * nrJf +
                                             (FxS1 * sxJa + FyS1 * syJa) * nsJf);
                          const dfloat F2 = ((FxS2 * rxJa + FyS2 * ryJa) * nrJf +
                                             (FxS2 * sxJa + FyS2 * syJa) * nsJf);
                          const dfloat F3 = ((FxS3 * rxJa + FyS3 * ryJa) * nrJf +
                                             (FxS3 * sxJa + FyS3 * syJa) * nsJf);
                          const dfloat F4 = ((FxS4 * rxJa + FyS4 * ryJa) * nrJf +
                                             (FxS4 * sxJa + FyS4 * syJa) * nsJf);
                          divF1 += VqLq_ij * F1;
                          divF2 += VqLq_ij * F2;
                          divF3 += VqLq_ij * F3;
                          divF4 += VqLq_ij * F4;
                        }

#if 0
                      if (k == 0)
                        {
                          printf("divF(%d,%d): %16.16f, %16.16f, %16.16f, %16.16f\n", i, k,
                                 divF1, divF2, divF3, divF4);
                          // printf("divF(%d,%d): %g, %g, %g,
                          // %g\n",i,k,divF1,divF2,divF3,divF4);
                        }
#endif

                      int id = i + k * p_Nfields * p_Nq;
                      rhsQ[id] = divF1;
                      id += p_Nq;
                      rhsQ[id] = divF2;
                      id += p_Nq;
                      rhsQ[id] = divF3;
                      id += p_Nq;
                      rhsQ[id] = divF4;
                    }

                  // now apply VfPq
                  if (i < p_NfqNfaces)
                    {

                      dfloat divF1 = 0.f;
                      dfloat divF2 = 0.f;
                      dfloat divF3 = 0.f;
                      dfloat divF4 = 0.f;

                      // redefine rho_i, etc...
                      const dfloat rho_i = srhof[k2][i];
                      const dfloat u_i = srhouf[k2][i] / rho_i;
                      const dfloat v_i = srhovf[k2][i] / rho_i;
                      const dfloat E_i = sEf[k2][i];
                      const dfloat beta_i = beta(rho_i, u_i, v_i, E_i);

                      const int f = i / p_Nfq;
                      const dfloat nrJf = s_nrJ[f];
                      const dfloat nsJf = s_nsJ[f];

                      const int gidi = i + k * p_NfqNfaces * p_Nvgeo;
                      const dfloat rxJi = vfgeo[gidi];
                      const dfloat ryJi = vfgeo[gidi + p_NfqNfaces];
                      const dfloat sxJi = vfgeo[gidi + 2*p_NfqNfaces];
                      const dfloat syJi = vfgeo[gidi + 3*p_NfqNfaces];      

                      for (int j = 0; j < p_Nq; ++j)
                        {
                          const dfloat VfPq_ij = -.5f * VfPq[i + j * p_NfqNfaces];

                          const dfloat rho_j = srho[k2][j];
                          const dfloat u_j = srhou[k2][j] / rho_j;
                          const dfloat v_j = srhov[k2][j] / rho_j;
                          const dfloat E_j = sE[k2][j];
                          const dfloat beta_j = beta(rho_j, u_j, v_j, E_j);

                          dfloat FxS1, FyS1, FxS2, FyS2, FxS3, FyS3, FxS4, FyS4;
                          euler2d_flux(rho_i, rho_j, u_i, u_j, v_i, v_j, E_i, E_j, beta_i,
                                       beta_j, FxS1, FyS1, FxS2, FyS2, FxS3, FyS3, FxS4,
                                       FyS4);

                          const int gidj = j + k * p_Nq * p_Nvgeo;
                          const dfloat rxJj = vgeo[gidj];
                          const dfloat ryJj = vgeo[gidj + p_Nq];
                          const dfloat sxJj = vgeo[gidj + 2*p_Nq];
                          const dfloat syJj = vgeo[gidj + 3*p_Nq];
              
                          const dfloat rxJa = .5f*(rxJi+rxJj);
                          const dfloat sxJa = .5f*(sxJi+sxJj);
                          const dfloat ryJa = .5f*(ryJi+ryJj);
                          const dfloat syJa = .5f*(syJi+syJj);                

              
                          const dfloat F1 = ((FxS1 * rxJa + FyS1 * ryJa) * nrJf +
                                             (FxS1 * sxJa + FyS1 * syJa) * nsJf);
                          const dfloat F2 = ((FxS2 * rxJa + FyS2 * ryJa) * nrJf +
                                             (FxS2 * sxJa + FyS2 * syJa) * nsJf);
                          const dfloat F3 = ((FxS3 * rxJa + FyS3 * ryJa) * nrJf +
                                             (FxS3 * sxJa + FyS3 * syJa) * nsJf);
                          const dfloat F4 = ((FxS4 * rxJa + FyS4 * ryJa) * nrJf +
                                             (FxS4 * sxJa + FyS4 * syJa) * nsJf);

                          divF1 += VfPq_ij * F1;
                          divF2 += VfPq_ij * F2;
                          divF3 += VfPq_ij * F3;
                          divF4 += VfPq_ij * F4;
                        }

                      // if (k==0){
                      //              printf("surf divF(%d,%d): %16.16f, %16.16f, %16.16f,
                      //%16.16f\n",i,k,divF1,divF2,divF3,divF4);
                      //            }

                      int idf = i + k * p_Nfields * p_NfqNfaces;
                      rhsQf[idf] = divF1;
                      idf += p_NfqNfaces;
                      rhsQf[idf] = divF2;
                      idf += p_NfqNfaces;
                      rhsQf[idf] = divF3;
                      idf += p_NfqNfaces;
                      rhsQf[idf] = divF4;

                    } // if i < p_NfqNfaces

                } // k < K
            }   // inner0
        }     // inner1
#endif
    }
}


// split part of kernel
kernel void euler_surf_2d(const int K, const dfloat *restrict fgeo,
                          const int *restrict mapPq,
                          const dfloat *restrict VqLq,
                          const dfloat *restrict Qf,
                          const dfloat *restrict rhsQf, dfloat *restrict rhsQ)
{

  // loop over elements
  for (int k1 = 0; k1 < (K + p_KblkS - 1) / p_KblkS; ++k1; outer0)
    {

      shared dfloat sfS1[p_KblkS][p_NfqNfaces];
      shared dfloat sfS2[p_KblkS][p_NfqNfaces];
      shared dfloat sfS3[p_KblkS][p_NfqNfaces];
      shared dfloat sfS4[p_KblkS][p_NfqNfaces];

      for (int k2 = 0; k2 < p_KblkS; ++k2; inner1)
        {
          for (int i = 0; i < p_T; ++i; inner0)
            {
              const int k = k1 * p_KblkS + k2;

              // read traces
              if ((k < K) && (i < p_NfqNfaces))
                {

                  int idM = i + k * p_NfqNfaces * p_Nfields;
                  int idP = mapPq[i + k * p_NfqNfaces];
                  const int isBoundary = idM == idP;

                  int fid = i + p_Nfgeo * p_NfqNfaces * k;
                  const dfloat nxJ = fgeo[fid + 0 * p_NfqNfaces];
                  const dfloat nyJ = fgeo[fid + 1 * p_NfqNfaces];
                  const dfloat sJ = fgeo[fid + 2 * p_NfqNfaces];

                  const dfloat rhoM = Qf[idM + 0 * p_NfqNfaces];
                  const dfloat rhouM = Qf[idM + 1 * p_NfqNfaces];
                  const dfloat rhovM = Qf[idM + 2 * p_NfqNfaces];
                  const dfloat EM = Qf[idM + 3 * p_NfqNfaces];

                  const dfloat rhoP = Qf[idP + 0 * p_NfqNfaces];
                  const dfloat rhouP = Qf[idP + 1 * p_NfqNfaces];
                  const dfloat rhovP = Qf[idP + 2 * p_NfqNfaces];
                  const dfloat EP = Qf[idP + 3 * p_NfqNfaces];

                  const dfloat uM = rhouM / rhoM;
                  const dfloat vM = rhovM / rhoM;
                  const dfloat uP = rhouP / rhoP;
                  const dfloat vP = rhovP / rhoP;
                  const dfloat betaM = beta(rhoM, uM, vM, EM);
                  const dfloat betaP = beta(rhoP, uP, vP, EP);

                  // if (isBoundary)
                  // {
                  //   // add BCs here - assume periodic for now
                  // }

                  dfloat FxS1, FyS1, FxS2, FyS2, FxS3, FyS3, FxS4, FyS4;
                  euler2d_flux(rhoM, rhoP, uM, uP, vM, vP, EM, EP, betaM, betaP, FxS1,
                               FyS1, FxS2, FyS2, FxS3, FyS3, FxS4, FyS4);

                  // entropy conservative fluxes + LF penalties
                  const dfloat lamM = sqrt(uM * uM + vM * vM) +
                    sqrt(p_gamma * pfun(rhoM, uM, vM, EM) / rhoM);
                  const dfloat lamP = sqrt(uP * uP + vP * vP) +
                    sqrt(p_gamma * pfun(rhoP, uP, vP, EP) / rhoP);
                  const dfloat Lfc_sJ =
                    .25f * max(lamM, lamP) *
                    sJ; // local max wavespeed estimate - assumes tau = 1

                  // add in rhsQf contribution
                  int id = i + k * p_Nfields * p_NfqNfaces;
                  const dfloat rhsQf1 = rhsQf[id];
                  id += p_NfqNfaces;
                  const dfloat rhsQf2 = rhsQf[id];
                  id += p_NfqNfaces;
                  const dfloat rhsQf3 = rhsQf[id];
                  id += p_NfqNfaces;
                  const dfloat rhsQf4 = rhsQf[id];

                  const dfloat drho = rhoP - rhoM;
                  const dfloat drhou = rhouP - rhouM;
                  const dfloat drhov = rhovP - rhovM;
                  const dfloat dE = EP - EM;

                  const dfloat fn1 = .5f * (FxS1 * nxJ + FyS1 * nyJ);
                  const dfloat fn2 = .5f * (FxS2 * nxJ + FyS2 * nyJ);
                  const dfloat fn3 = .5f * (FxS3 * nxJ + FyS3 * nyJ);
                  const dfloat fn4 = .5f * (FxS4 * nxJ + FyS4 * nyJ);
                  //      if (k==0){
                  //        printf("fn+rhsQf = %16.16f, %16.16f, %16.16f,
                  //%16.16f\n",fn1+rhsQf1,fn2+rhsQf2,fn3+rhsQf3,fn4+rhsQf4);
                  //      }

                  sfS1[k2][i] = fn1 + rhsQf1 - Lfc_sJ * drho;
                  sfS2[k2][i] = fn2 + rhsQf2 - Lfc_sJ * drhou;
                  sfS3[k2][i] = fn3 + rhsQf3 - Lfc_sJ * drhov;
                  sfS4[k2][i] = fn4 + rhsQf4 - Lfc_sJ * dE;

                } // if k < K and i < NfqNfaces
            }
        }
      barrier(localMemFence);

      // apply lift to accumulated flux
      for (int k2 = 0; k2 < p_KblkS; ++k2; inner1)
        {
          for (int i = 0; i < p_T; ++i; inner0)
            {

              const int k = k1 * p_KblkS + k2;
              if (k < K && i < p_Nq)
                {

                  // accumulate lifted contributions into vol rhs
                  dfloat val1 = 0.f, val2 = 0.f, val3 = 0.f, val4 = 0.f;

                  for (int j = 0; j < p_NfqNfaces; ++j)
                    {
                      const dfloat VqLq_ij = VqLq[i + j * p_Nq];

                      val1 += VqLq_ij * sfS1[k2][j];
                      val2 += VqLq_ij * sfS2[k2][j];
                      val3 += VqLq_ij * sfS3[k2][j];
                      val4 += VqLq_ij * sfS4[k2][j];
                    }

                  // printf("surface terms: %f, %f, %f, %f\n", val1,val2,val3,val4);

                  int id = i + k * p_Nfields * p_Nq;
                  rhsQ[id + 0 * p_Nq] += val1;
                  rhsQ[id + 1 * p_Nq] += val2;
                  rhsQ[id + 2 * p_Nq] += val3;
                  rhsQ[id + 3 * p_Nq] += val4;
                }
            }
        }
    }
}

// Nq loop - non-curved. For WADG, add Vq*Pq step
kernel void euler_update_2d(const int K, const dfloat *restrict Jq,
                            const dfloat *restrict VqPq, // eval at qpts
                            const dfloat *restrict VfPq, // eval at fpts
                            const dfloat fa, const dfloat fb, const dfloat fdt,
                            dfloat *restrict rhsQ, dfloat *restrict resQ,
                            dfloat *restrict Q, dfloat *restrict Qf)
{

  for (int k1 = 0; k1 < (K + p_KblkU - 1) / p_KblkU; ++k1; outer0)
    {

      shared dfloat srho[p_KblkU][p_Nq];
      shared dfloat srhou[p_KblkU][p_Nq];
      shared dfloat srhov[p_KblkU][p_Nq];
      shared dfloat sE[p_KblkU][p_Nq];

      // use double smem instead of register
      // since we're not storing trace dofs?
      shared dfloat sV1[p_KblkU][p_Nq];
      shared dfloat sV2[p_KblkU][p_Nq];
      shared dfloat sV3[p_KblkU][p_Nq];
      shared dfloat sV4[p_KblkU][p_Nq];

      // load in RHS to project
      for (int k2 = 0; k2 < p_KblkU; ++k2; inner1)
        {
          for (int i = 0; i < p_Nq; ++i; inner0)
            {

              const int k = k1 * p_KblkU + k2;

              if (k < K)
                {
                  int id = i + k * p_Nq * p_Nfields;
                  srho[k2][i] = rhsQ[id + 0 * p_Nq];
                  srhou[k2][i] = rhsQ[id + 1 * p_Nq];
                  srhov[k2][i] = rhsQ[id + 2 * p_Nq];
                  sE[k2][i] = rhsQ[id + 3 * p_Nq];
                }
            }
        }
      barrier(localMemFence);

      // project RHS and increment U
      for (int k2 = 0; k2 < p_KblkU; ++k2; inner1)
        {
          for (int i = 0; i < p_Nq; ++i; inner0)
            {

              const int k = k1 * p_KblkU + k2;

              if (k < K)
                {
                  // prefetch Jacobian
                  const dfloat Jqi = Jq[i + k * p_Nq];

                  dfloat r1 = 0.f;
                  dfloat r2 = 0.f;
                  dfloat r3 = 0.f;
                  dfloat r4 = 0.f;
                  for (int j = 0; j < p_Nq; ++j)
                    {

                      // note 2*rhs = from flux differencing formulation
                      const dfloat VqPq_ij = -2.f * VqPq[i + j * p_Nq];
                      r1 += VqPq_ij * srho[k2][j];
                      r2 += VqPq_ij * srhou[k2][j];
                      r3 += VqPq_ij * srhov[k2][j];
                      r4 += VqPq_ij * sE[k2][j];
                    }
                  r1 /= Jqi;
                  r2 /= Jqi;
                  r3 /= Jqi;
                  r4 /= Jqi;

                  // printf("r = %f, %f, %f, %f\n",r1,r2,r3,r4);

                  // retrieve res arrays
                  dfloat resx, resy, resz, resw;
                  int id = i + k * p_Nq * p_Nfields;
                  resx = resQ[id + 0 * p_Nq];
                  resy = resQ[id + 1 * p_Nq];
                  resz = resQ[id + 2 * p_Nq];
                  resw = resQ[id + 3 * p_Nq];

                  // update res arrays
                  id = i + k * p_Nq * p_Nfields;
                  resx = fa * resx + fdt * r1;
                  resy = fa * resy + fdt * r2;
                  resz = fa * resz + fdt * r3;
                  resw = fa * resw + fdt * r4;

                  // store res arrays
                  id = i + k * p_Nq * p_Nfields;
                  resQ[id] = resx;
                  id += p_Nq;
                  resQ[id] = resy;
                  id += p_Nq;
                  resQ[id] = resz;
                  id += p_Nq;
                  resQ[id] = resw;

                  // update soln vars
                  id = i + k * p_Nq * p_Nfields;
                  dfloat rho = Q[id + 0 * p_Nq];
                  dfloat rhou = Q[id + 1 * p_Nq];
                  dfloat rhov = Q[id + 2 * p_Nq];
                  dfloat E = Q[id + 3 * p_Nq];

                  rho += fb * resx;
                  rhou += fb * resy;
                  rhov += fb * resz;
                  E += fb * resw;

                  /*      if (k==0){
                          printf("updated U: %f, %f, %f, %f\n",rho,rhou,rhov,E);
                          }*/

                  Q[id + 0 * p_Nq] = rho;
                  Q[id + 1 * p_Nq] = rhou;
                  Q[id + 2 * p_Nq] = rhov;
                  Q[id + 3 * p_Nq] = E;

                  // printf("rho,rhou,rhov,E = %f, %f, %f, %f\n",rho,rhou,rhov,E);

                  // evaluate entropy variables at updated vars
                  dfloat V1, V2, V3, V4;
                  VU(rho, rhou, rhov, E, V1, V2, V3, V4);

                  //      if (k==0){
                  //        printf("Vu = %f, %f, %f, %f\n", V1,V2,V3,V4);
                  //      }

                  // smem transfer
                  sV1[k2][i] = V1;
                  sV2[k2][i] = V2;
                  sV3[k2][i] = V3;
                  sV4[k2][i] = V4;
                }

            } // inner 0
        }   // inner1

      barrier(localMemFence);

      // project to nodal dofs
      for (int k2 = 0; k2 < p_KblkU; ++k2; inner1)
        {
          for (int i = 0; i < p_Nq; ++i; inner0)
            {

              const int k = k1 * p_KblkU + k2;

              if (k < K)
                {

                  // this can be made more efficient
                  int ii = i;
                  while (ii < p_NfqNfaces)
                    {
                      dfloat V1 = 0.f;
                      dfloat V2 = 0.f;
                      dfloat V3 = 0.f;
                      dfloat V4 = 0.f;
                      for (int j = 0; j < p_Nq; ++j)
                        {
                          const dfloat VfPq_ij = VfPq[ii + j * p_NfqNfaces];
                          V1 += VfPq_ij * sV1[k2][j];
                          V2 += VfPq_ij * sV2[k2][j];
                          V3 += VfPq_ij * sV3[k2][j];
                          V4 += VfPq_ij * sV4[k2][j];
                        }

                      const int id = ii + k * p_NfqNfaces * p_Nfields;

                      // eval conserv vars in terms of entropy vars
                      dfloat rho, rhou, rhov, E;
                      UV(V1, V2, V3, V4, rho, rhou, rhov, E);

                      //            if (k==0){
                      //              printf("Uvf = %f, %f, %f, %f\n",rho,rhou,rhov,E);
                      //            }

                      Qf[id + 0 * p_NfqNfaces] = rho;
                      Qf[id + 1 * p_NfqNfaces] = rhou;
                      Qf[id + 2 * p_NfqNfaces] = rhov;
                      Qf[id + 3 * p_NfqNfaces] = E;
                      ii += p_Nq;
                    }

                  // entropy variable projection
                  dfloat V1 = 0.f;
                  dfloat V2 = 0.f;
                  dfloat V3 = 0.f;
                  dfloat V4 = 0.f;
                  for (int j = 0; j < p_Nq; ++j)
                    {
                      const dfloat VqPq_ij = VqPq[i + j * p_Nq];
                      //            if (k==0){
                      //              printf("VqPq(%d,%d) = %f\n",i+1,j+1,VqPq_ij);
                      //            }
                      V1 += VqPq_ij * sV1[k2][j];
                      V2 += VqPq_ij * sV2[k2][j];
                      V3 += VqPq_ij * sV3[k2][j];
                      V4 += VqPq_ij * sV4[k2][j];
                    }

                  // evaluate U(P*V) and write out
                  dfloat rho, rhou, rhov, E;
                  UV(V1, V2, V3, V4, rho, rhou, rhov, E);

                  //      if (k==0){
                  //        printf("Uv = %f, %f, %f, %f\n",rho,rhou,rhov,E);
                  //      }

                  const int id = i + k * p_Nq * p_Nfields;
                  rhsQ[id + 0 * p_Nq] = rho;
                  rhsQ[id + 1 * p_Nq] = rhou;
                  rhsQ[id + 2 * p_Nq] = rhov;
                  rhsQ[id + 3 * p_Nq] = E;

                } // end if

            } // inner0
        }   // inner1

    } // outer 0
}


// Nq loop - non-curved. For WADG, add Vq*Pq step
kernel void euler_update_2d_curved(const int K, const dfloat *restrict Jq,
                                   const dfloat *restrict VqPq, // eval at qpts
                                   const dfloat *restrict VfPq, // eval at fpts
                                   const dfloat fa, const dfloat fb, const dfloat fdt,
                                   dfloat *restrict rhsQ, dfloat *restrict resQ,
                                   dfloat *restrict Q, dfloat *restrict Qf)
{

  for (int k1 = 0; k1 < (K + p_KblkU - 1) / p_KblkU; ++k1; outer0)
    {

      shared dfloat srho[p_KblkU][p_Nq];
      shared dfloat srhou[p_KblkU][p_Nq];
      shared dfloat srhov[p_KblkU][p_Nq];
      shared dfloat sE[p_KblkU][p_Nq];

      // use double smem instead of register
      // since we're not storing trace dofs?
      shared dfloat sV1[p_KblkU][p_Nq];
      shared dfloat sV2[p_KblkU][p_Nq];
      shared dfloat sV3[p_KblkU][p_Nq];
      shared dfloat sV4[p_KblkU][p_Nq];
shared int max_iter;

      // load in RHS to project
#ifndef TESTING
      if (K <= (k1+1)*p_KblkU){
        max_iter = K - (k1 * p_KblkU);
      }else{
        max_iter = p_KblkU;
      }
      for (int k2 = 0; k2 < max_iter; ++k2; inner1)
        {
          for (int i = 0; i < p_Nq; ++i; inner0)
            {
              const int k = k1 * p_KblkU + k2;
              int id = i + k * p_Nq * p_Nfields;
              srho[k2][i] = rhsQ[id + 0 * p_Nq];
              srhou[k2][i] = rhsQ[id + 1 * p_Nq];
              srhov[k2][i] = rhsQ[id + 2 * p_Nq];
              sE[k2][i] = rhsQ[id + 3 * p_Nq];
            }
        }
#else
      for (int k2 = 0; k2 < p_KblkU; ++k2; inner1)
        {
          for (int i = 0; i < p_Nq; ++i; inner0)
            {
              
              const int k = k1 * p_KblkU + k2;
              
              if (k < K)
                {
                  int id = i + k * p_Nq * p_Nfields;
                  srho[k2][i] = rhsQ[id + 0 * p_Nq];
                  srhou[k2][i] = rhsQ[id + 1 * p_Nq];
                  srhov[k2][i] = rhsQ[id + 2 * p_Nq];
                  sE[k2][i] = rhsQ[id + 3 * p_Nq];
                }
            }
        }
#endif
      barrier(localMemFence);

      // project RHS and increment U
#ifdef TESTING
      if (K <= (k1+1)*p_KblkU){
        max_iter = K - (k1 * p_KblkU);
      }else{
        max_iter = p_KblkU;
      }
      for (int k2 = 0; k2 < max_iter; ++k2; inner1)
        {
          for (int i = 0; i < p_Nq; ++i; inner0)
            {

              const int k = k1 * p_KblkU + k2;

                  // prefetch Jacobian
                  const dfloat Jqi = Jq[i + k * p_Nq];

                  dfloat r1 = 0.f; dfloat r2 = 0.f;
                  dfloat r3 = 0.f; dfloat r4 = 0.f;
                  for (int j = 0; j < p_Nq; ++j)
                    {
                      // note 2*rhs = from flux differencing formulation
                      const dfloat VqPq_ij = -2.f * VqPq[i + j * p_Nq];
                      r1 += VqPq_ij * srho[k2][j];
                      r2 += VqPq_ij * srhou[k2][j];
                      r3 += VqPq_ij * srhov[k2][j];
                      r4 += VqPq_ij * sE[k2][j];
                    }

                  // divide by J, then re-project for WADG.
                  sV1[k2][i] = r1 / Jqi;
                  sV2[k2][i] = r2 / Jqi;
                  sV3[k2][i] = r3 / Jqi;
                  sV4[k2][i] = r4 / Jqi;
            }
        }
#else
      for (int k2 = 0; k2 < p_KblkU; ++k2; inner1)
        {
          for (int i = 0; i < p_Nq; ++i; inner0)
            {

              const int k = k1 * p_KblkU + k2;

              if (k < K)
                {
                  // prefetch Jacobian
                  const dfloat Jqi = Jq[i + k * p_Nq];

                  dfloat r1 = 0.f; dfloat r2 = 0.f;
                  dfloat r3 = 0.f; dfloat r4 = 0.f;
                  for (int j = 0; j < p_Nq; ++j)
                    {
                      // note 2*rhs = from flux differencing formulation
                      const dfloat VqPq_ij = -2.f * VqPq[i + j * p_Nq];
                      r1 += VqPq_ij * srho[k2][j];
                      r2 += VqPq_ij * srhou[k2][j];
                      r3 += VqPq_ij * srhov[k2][j];
                      r4 += VqPq_ij * sE[k2][j];
                    }

                  // divide by J, then re-project for WADG.
                  sV1[k2][i] = r1 / Jqi;
                  sV2[k2][i] = r2 / Jqi;
                  sV3[k2][i] = r3 / Jqi;
                  sV4[k2][i] = r4 / Jqi;
                }
            }
        }
#endif
      barrier(localMemFence);
#ifdef TESTING
/*
      if (K <= (k1+1)*p_KblkU){
        max_iter = K - (k1 * p_KblkU);
      }else{
        max_iter = p_KblkU;
      }
*/
      for (int k2 = 0; k2 < max_iter; ++k2; inner1){
        for(int i = 0; i < p_Nq; ++i; inner0){
              const int k = k1 * p_KblkU + k2;

                  // re-apply L2 projection for WADG
                  dfloat r1 = 0.f;
                  dfloat r2 = 0.f;
                  dfloat r3 = 0.f;
                  dfloat r4 = 0.f;                
                  for (int j = 0; j < p_Nq; ++j)
                    {
                      const dfloat VqPq_ij = VqPq[i + j * p_Nq];
                      r1 += VqPq_ij * sV1[k2][j];
                      r2 += VqPq_ij * sV2[k2][j];
                      r3 += VqPq_ij * sV3[k2][j];
                      r4 += VqPq_ij * sV4[k2][j];
                    }

                  // retrieve res arrays
                  dfloat resx, resy, resz, resw;
                  int id = i + k * p_Nq * p_Nfields;
                  resx = resQ[id + 0 * p_Nq];
                  resy = resQ[id + 1 * p_Nq];
                  resz = resQ[id + 2 * p_Nq];
                  resw = resQ[id + 3 * p_Nq];

                  // update res arrays
                  id = i + k * p_Nq * p_Nfields;
                  resx = fa * resx + fdt * r1;
                  resy = fa * resy + fdt * r2;
                  resz = fa * resz + fdt * r3;
                  resw = fa * resw + fdt * r4;

                  // store res arrays
                  id = i + k * p_Nq * p_Nfields;
                  resQ[id] = resx;
                  id += p_Nq;
                  resQ[id] = resy;
                  id += p_Nq;
                  resQ[id] = resz;
                  id += p_Nq;
                  resQ[id] = resw;

                  // update soln vars
                  id = i + k * p_Nq * p_Nfields;
                  dfloat rho = Q[id + 0 * p_Nq];
                  dfloat rhou = Q[id + 1 * p_Nq];
                  dfloat rhov = Q[id + 2 * p_Nq];
                  dfloat E = Q[id + 3 * p_Nq];

                  rho += fb * resx;
                  rhou += fb * resy;
                  rhov += fb * resz;
                  E += fb * resw;

                  Q[id + 0 * p_Nq] = rho;
                  Q[id + 1 * p_Nq] = rhou;
                  Q[id + 2 * p_Nq] = rhov;
                  Q[id + 3 * p_Nq] = E;

                  // evaluate entropy variables at updated vars
                  dfloat V1, V2, V3, V4;
                  VU(rho, rhou, rhov, E, V1, V2, V3, V4);

                  // smem transfer, premult for WADG
                  const dfloat Jqi = Jq[i + k * p_Nq];            
                  srho[k2][i] = V1 * Jqi;
                  srhou[k2][i] = V2 * Jqi;
                  srhov[k2][i] = V3 * Jqi;
                  sE[k2][i] = V4 * Jqi;
            }
        }
#else
      for (int k2 = 0; k2 < p_KblkU; ++k2; inner1){
        for (int i = 0; i < p_Nq; ++i; inner0){

              const int k = k1 * p_KblkU + k2;

              if (k < K)
                {

                  // re-apply L2 projection for WADG
                  dfloat r1 = 0.f;
                  dfloat r2 = 0.f;
                  dfloat r3 = 0.f;
                  dfloat r4 = 0.f;                
                  for (int j = 0; j < p_Nq; ++j)
                    {
                      const dfloat VqPq_ij = VqPq[i + j * p_Nq];
                      r1 += VqPq_ij * sV1[k2][j];
                      r2 += VqPq_ij * sV2[k2][j];
                      r3 += VqPq_ij * sV3[k2][j];
                      r4 += VqPq_ij * sV4[k2][j];
                    }

                  // retrieve res arrays
                  dfloat resx, resy, resz, resw;
                  int id = i + k * p_Nq * p_Nfields;
                  resx = resQ[id + 0 * p_Nq];
                  resy = resQ[id + 1 * p_Nq];
                  resz = resQ[id + 2 * p_Nq];
                  resw = resQ[id + 3 * p_Nq];

                  // update res arrays
                  id = i + k * p_Nq * p_Nfields;
                  resx = fa * resx + fdt * r1;
                  resy = fa * resy + fdt * r2;
                  resz = fa * resz + fdt * r3;
                  resw = fa * resw + fdt * r4;

                  // store res arrays
                  id = i + k * p_Nq * p_Nfields;
                  resQ[id] = resx;
                  id += p_Nq;
                  resQ[id] = resy;
                  id += p_Nq;
                  resQ[id] = resz;
                  id += p_Nq;
                  resQ[id] = resw;

                  // update soln vars
                  id = i + k * p_Nq * p_Nfields;
                  dfloat rho = Q[id + 0 * p_Nq];
                  dfloat rhou = Q[id + 1 * p_Nq];
                  dfloat rhov = Q[id + 2 * p_Nq];
                  dfloat E = Q[id + 3 * p_Nq];

                  rho += fb * resx;
                  rhou += fb * resy;
                  rhov += fb * resz;
                  E += fb * resw;

                  Q[id + 0 * p_Nq] = rho;
                  Q[id + 1 * p_Nq] = rhou;
                  Q[id + 2 * p_Nq] = rhov;
                  Q[id + 3 * p_Nq] = E;

                  // evaluate entropy variables at updated vars
                  dfloat V1, V2, V3, V4;
                  VU(rho, rhou, rhov, E, V1, V2, V3, V4);

                  // smem transfer, premult for WADG
                  const dfloat Jqi = Jq[i + k * p_Nq];            
                  srho[k2][i] = V1 * Jqi;
                  srhou[k2][i] = V2 * Jqi;
                  srhov[k2][i] = V3 * Jqi;
                  sE[k2][i] = V4 * Jqi;
                }
            }
        }
#endif
      barrier(localMemFence);
      
#ifdef TESTING
/*
      if (K <= (k1+1)*p_KblkU){
        max_iter = K - (k1 * p_KblkU);
      }else{
        max_iter = p_KblkU;
      }
*/
      for (int k2 = 0; k2 < max_iter; ++k2; inner1){
        for(int i = 0; i < p_Nq; ++i; inner0){
          const int k = k1 * p_KblkU + k2;       
          const dfloat Jqi = Jq[i + k * p_Nq];                      
          // apply WADG projection P*(1/J * P(uJ))
          dfloat r1 = 0.f;
          dfloat r2 = 0.f;
          dfloat r3 = 0.f;
          dfloat r4 = 0.f;                
          for (int j = 0; j < p_Nq; ++j)
            {
              const dfloat VqPq_ij = VqPq[i + j * p_Nq];
              r1 += VqPq_ij * srho[k2][j];
              r2 += VqPq_ij * srhou[k2][j];
              r3 += VqPq_ij * srhov[k2][j];
              r4 += VqPq_ij * sE[k2][j];
            }
          sV1[k2][i] = r1/Jqi;
          sV2[k2][i] = r2/Jqi;
          sV3[k2][i] = r3/Jqi;
          sV4[k2][i] = r4/Jqi;
        }
      }
#else
      for (int k2 = 0; k2 < p_KblkU; ++k2; inner1){
        for (int i = 0; i < p_Nq; ++i; inner0){
          const int k = k1 * p_KblkU + k2;       
          if (k < K){

            const dfloat Jqi = Jq[i + k * p_Nq];                            
            // apply WADG projection P*(1/J * P(uJ))
            dfloat r1 = 0.f;
            dfloat r2 = 0.f;
            dfloat r3 = 0.f;
            dfloat r4 = 0.f;              
            for (int j = 0; j < p_Nq; ++j)
              {
                const dfloat VqPq_ij = VqPq[i + j * p_Nq];
                r1 += VqPq_ij * srho[k2][j];
                r2 += VqPq_ij * srhou[k2][j];
                r3 += VqPq_ij * srhov[k2][j];
                r4 += VqPq_ij * sE[k2][j];
              }
            sV1[k2][i] = r1/Jqi;
            sV2[k2][i] = r2/Jqi;
            sV3[k2][i] = r3/Jqi;
            sV4[k2][i] = r4/Jqi;
          }
        }
      }
#endif
      barrier(localMemFence);

#ifdef TESTING
/*
      if (K <= (k1+1)*p_KblkU){
        max_iter = K - (k1 * p_KblkU);
      }else{
        max_iter = p_KblkU;
      }
*/
      for (int k2 = 0; k2 < max_iter; ++k2; inner1){
        for(int i = 0; i < p_Nq; ++i; inner0){
          dfloat r1 = 0.f;
          dfloat r2 = 0.f;
          dfloat r3 = 0.f;
          dfloat r4 = 0.f;
          for (int j = 0; j < p_Nq; ++j){
            const dfloat VqPq_ij = VqPq[i + j * p_Nq];
            r1 += VqPq_ij * sV1[k2][j];
            r2 += VqPq_ij * sV2[k2][j];
            r3 += VqPq_ij * sV3[k2][j];
            r4 += VqPq_ij * sV4[k2][j];
          }
          srho[k2][i] = r1;
          srhou[k2][i] = r2;
          srhov[k2][i] = r3;
          sE[k2][i] = r4;
        } // inner 0
      } // inner 1

#else
      for (int k2 = 0; k2 < p_KblkU; ++k2; inner1){
        for (int i = 0; i < p_Nq; ++i; inner0){
          const int k = k1 * p_KblkU + k2;       
          if (k < K){
      
            dfloat r1 = 0.f;
            dfloat r2 = 0.f;
            dfloat r3 = 0.f;
            dfloat r4 = 0.f;              
            for (int j = 0; j < p_Nq; ++j)
              {
                const dfloat VqPq_ij = VqPq[i + j * p_Nq];
                r1 += VqPq_ij * sV1[k2][j];
                r2 += VqPq_ij * sV2[k2][j];
                r3 += VqPq_ij * sV3[k2][j];
                r4 += VqPq_ij * sV4[k2][j];
              }
            srho[k2][i] = r1;
            srhou[k2][i] = r2;
            srhov[k2][i] = r3;
            sE[k2][i] = r4;
            
          }
          
        } // inner 0
      }   // inner1
#endif
      
      barrier(localMemFence);

#ifdef TESTING
      // project to nodal dofs
      for (int k2 = 0; k2 < max_iter; ++k2; inner0)
        {
          for (int i = 0; i < p_Nq; ++i; inner1)
            {

              const int k = k1 * p_KblkU + k2;

                  // this can be made more efficient
                  int ii = i;
                  while (ii < p_NfqNfaces)
                    {
                      dfloat V1 = 0.f;
                      dfloat V2 = 0.f;
                      dfloat V3 = 0.f;
                      dfloat V4 = 0.f;
                      for (int j = 0; j < p_Nq; ++j)
                        {
                          const dfloat VfPq_ij = VfPq[ii + j * p_NfqNfaces];
                          V1 += VfPq_ij * srho[k2][j];
                          V2 += VfPq_ij * srhou[k2][j];
                          V3 += VfPq_ij * srhov[k2][j];
                          V4 += VfPq_ij * sE[k2][j];
                        }

                      const int id = ii + k * p_NfqNfaces * p_Nfields;

                      // eval conserv vars in terms of entropy vars
                      dfloat rho, rhou, rhov, E;
                      UV(V1, V2, V3, V4, rho, rhou, rhov, E);

                      Qf[id + 0 * p_NfqNfaces] = rho;
                      Qf[id + 1 * p_NfqNfaces] = rhou;
                      Qf[id + 2 * p_NfqNfaces] = rhov;
                      Qf[id + 3 * p_NfqNfaces] = E;
                      ii += p_Nq;
                    }

                  // entropy variable projection
                  dfloat V1 = 0.f;
                  dfloat V2 = 0.f;
                  dfloat V3 = 0.f;
                  dfloat V4 = 0.f;
                  for (int j = 0; j < p_Nq; ++j)
                    {
                      const dfloat VqPq_ij = VqPq[i + j * p_Nq];
                      V1 += VqPq_ij * srho[k2][j];
                      V2 += VqPq_ij * srhou[k2][j];
                      V3 += VqPq_ij * srhov[k2][j];
                      V4 += VqPq_ij * sE[k2][j];
                    }

                  // evaluate U(P*V) and write out
                  dfloat rho, rhou, rhov, E;
                  UV(V1, V2, V3, V4, rho, rhou, rhov, E);

                  const int id = i + k * p_Nq * p_Nfields;
                  rhsQ[id + 0 * p_Nq] = rho;
                  rhsQ[id + 1 * p_Nq] = rhou;
                  rhsQ[id + 2 * p_Nq] = rhov;
                  rhsQ[id + 3 * p_Nq] = E;

            } // inner1
        }   // inner0
#else
      // project to nodal dofs
      for (int k2 = 0; k2 < p_KblkU; ++k2; inner1)
        {
          for (int i = 0; i < p_Nq; ++i; inner0)
            {

              const int k = k1 * p_KblkU + k2;

              if (k < K)
                {  

                  // this can be made more efficient
                  int ii = i;
                  while (ii < p_NfqNfaces)
                    {
                      dfloat V1 = 0.f;
                      dfloat V2 = 0.f;
                      dfloat V3 = 0.f;
                      dfloat V4 = 0.f;
                      for (int j = 0; j < p_Nq; ++j)
                        {
                          const dfloat VfPq_ij = VfPq[ii + j * p_NfqNfaces];
                          V1 += VfPq_ij * srho[k2][j];
                          V2 += VfPq_ij * srhou[k2][j];
                          V3 += VfPq_ij * srhov[k2][j];
                          V4 += VfPq_ij * sE[k2][j];
                        }

                      const int id = ii + k * p_NfqNfaces * p_Nfields;

                      // eval conserv vars in terms of entropy vars
                      dfloat rho, rhou, rhov, E;
                      UV(V1, V2, V3, V4, rho, rhou, rhov, E);

                      Qf[id + 0 * p_NfqNfaces] = rho;
                      Qf[id + 1 * p_NfqNfaces] = rhou;
                      Qf[id + 2 * p_NfqNfaces] = rhov;
                      Qf[id + 3 * p_NfqNfaces] = E;
                      ii += p_Nq;
                    }

                  // entropy variable projection
                  dfloat V1 = 0.f;
                  dfloat V2 = 0.f;
                  dfloat V3 = 0.f;
                  dfloat V4 = 0.f;
                  for (int j = 0; j < p_Nq; ++j)
                    {
                      const dfloat VqPq_ij = VqPq[i + j * p_Nq];
                      V1 += VqPq_ij * srho[k2][j];
                      V2 += VqPq_ij * srhou[k2][j];
                      V3 += VqPq_ij * srhov[k2][j];
                      V4 += VqPq_ij * sE[k2][j];
                    }

                  // evaluate U(P*V) and write out
                  dfloat rho, rhou, rhov, E;
                  UV(V1, V2, V3, V4, rho, rhou, rhov, E);

                  const int id = i + k * p_Nq * p_Nfields;
                  rhsQ[id + 0 * p_Nq] = rho;
                  rhsQ[id + 1 * p_Nq] = rhou;
                  rhsQ[id + 2 * p_Nq] = rhov;
                  rhsQ[id + 3 * p_Nq] = E;

                } // end if

            } // inner0
        }   // inner1
#endif
    } // outer 0
}
